---
sort: 5
---

# Matrix Chain Multiplication



* 행렬의 곱을 계산할 때, 최소의 곳셈 횟수를 계산하는 DP
* A, B, C 라는 3개의 행렬이 존재하고, A =``a*b``, B = ``b*c``, C = ``c*d`` 를 성립할 때,  행렬의 곱은 결합 법칙을 만족하기 때문에 순서와 관계없이 최종적으로 동일한 값을 보인다.
  * (AB)C = A(BC)
  * (AB)C의 연산 횟수 : abc + acd = ac(b+d)
  * A(BC)의 연산 횟수 : abd + bcd = bd(a+c)
* 결합 법칙에 의해 동일한 값을 나타내지만 횟수의 차이가 있다.
* 참고로, n차 정사각행렬 거듭제곱인 $$N^k$$ 의 덧셈 연산 횟수는 $$(k-1)*n^3$$ 이다. 



* Matrix Chain Mulmiplication은 2차원 DP로 계산하며, ``DP[X][Y]`` 는 행렬X부터  행렬Y까지의 최소 비용을 나타낸다

  * 따라서 ``DP[i][i]`` 는 0으로 표현되고, 최종적으로 ``DP[1][n]`` 을 계산해야 된다.

  * ``dp[1][n] = dp[1][k] + dp[k][n]`` 와 같이 구간을 나누어 계산할 수 있다.

    * Divide & Conquer로 n개의 행렬을 재귀적으로 2개의 행렬곱으로 나눈다

    * n개의 행렬을 결합 법칙에 의해 2개의 행렬곱으로 나누는 횟수는 총 n-1개이다

      * A B C D 4개의 행렬인 경우
        * A(BCD)
        * (AB)(CD)
        * (ABC)D

    * 분할의 곳셈 횟수

      * (AB)(CD) 인 경우
        * (AB) 의 곳셈횟수 + (CD)의 곳셈횟수 + 두 행렬의 곳셈횟수
        * 두 행렬의 곳셈 횟수
          * $$d_0$$ : `dp[1][2]` 의 **행**의 갯수
          * $$d_4$$ : `dp[3][4]` 의 **열**의 갯수
          * $$d_2$$ : `dp[1][2]` 의 **열**의 갯수 = `dp[3][4]` 의 **행**의 갯수
          * 두 행렬의 곱 : $$d_0d_2d_4$$
        * ``dp[1][2] + dp[3][4]`` + $$d_0d_2d_4$$

      * 점화식

        ```c++
        if (i == j) dp[i][j] = 0;
        if (i < j)
        	dp[i][j] = min(dp[i][k] + dp[k + 1][j] + d[i - 1]*d[k]*d[j])  (i<=k<=j)
        ```

* ``dp[1][4]`` 인 경우

  * ``dp[1][4]`` = min(`dp[1][1]` + `dp[2][4]` + $$d_0d_1d_4$$,

    ​							   `dp[1][2]`  +`dp[3][4]` + $$d_0d_2d_4$$ ,

    ​								`dp[1][3]` + `dp[4][4]` + $$d_0d_3d_4$$)

* 처음에 대각선 `dp[i][i] = 0` 을 반영

|      | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | x    | x    |      |
| 2    |      | 0    |      | x    |
| 3    |      |      | 0    | x    |
| 4    |      |      |      | 0    |

* 대각선 (Diagnal)을 기준으로 상향식으로 접근한다.
* 위 표에서 x로 되어 있는 값이 필요함
  * `dp[1][2]` = `dp[1][1] ` + `dp[2][2]` + $$d_0d_1d_2$$
  * `dp[1][3]` 은 $$k=1$$ 인 경우와 $$k=2$$ 인 경우 2가지의 최솟값을 계산해야되는데, `dp[1][2]` or `dp[2][3]` 의 값이 필요함
    * `dp[2][4]` 도 마찬가지
  * `dp[3][4]` = `dp[3][3]` + `dp[4][4] ` + $$d_2d_3d_4$$ 
* 위 예시를 통해 확인할 수 있는 것은 새로 추가되는 값은 이미 값이 채워진 인접한 cell에서 우/상향으로 계산됨 (상향식)

### Code

```c++
ll MCM(int n){
    memset(dp, -1, sizeof(dp));
    for (int i=0;i<=n;i++) dp[i][i] = 0;
    for (int i=n-1;i>=0;i--){ // from n-1 rows
        for (int j=i+1; j<n;j++){ // diagnal
            dp[i][j] = INF;
            for (int k=i;k<=j;k++){
                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j] + vc[i].first*vc[k].second*vc[j].second);
            }
        }
    }
    return dp[0][n-1];
}
```



