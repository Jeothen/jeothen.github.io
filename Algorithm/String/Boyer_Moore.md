---
sort: 5
---

# Boyer Moore

* Boyer Moore 알고리즘은 두가지 접근법을 조합하여 최적의 방법으로 문자를 비교

* Rabin-Karp와 KMP는 왼쪽에서 오른쪽으로 비교했지만, Boyer Moore는 오른쪽에서 왼쪽으로 비교

  * 문자열을 skip할 때는 왼쪽에서 오른쪽으로 진행

* 두가지 접근법은 Bad Character / Good Suffix

* **Bad Characeter**

  * 패턴의 문자와 일치하지 않는 텍스트의 문자를 Bad Character라고 함
  * Bad Character는 문자열 내에 속한 문자의 가장 오른쪽 인덱스를 저장
    * 존재하지 않는 문자는 -1로 저장하는 것이 일반적

  ```c++
  
  vector<int> createBC(string pat)
  {
      int M = pat.length();
      vector<int>bc(NUM_OF_CHARS);
      for (int i = 0; i < NUM_OF_CHARS; ++i) bc[i] = -1;
      for (int i = 0; i < M - 1; ++i) bc[(int)pat[i]] = i;
      return bc;
  }
  
  void searchBM(string pat, string txt)
  {
      int N = txt.length(), M = pat.length();
      vector<int>bc = createBC(pat);
  
      int s = 0;
      int j = 0;
      
      while (s <= (N - M))
      {
          j = M - 1; // from last character
          while (j >= 0 && pat[j] == txt[s + j]) j--;
  
          if (j < 0)
          {
              printf("Pattern found at index %d \n", s);
              s += (s + M < N) ? M - bc[txt[s + M]] : 1;
          }
          else
          {
              s += max(1, j - bc[txt[s + j]]);
          }
      }
  }
  ```

  * return으로 받은 bc를 이용하여 문자열 간 비교를 수행

  * text : `AABACAADAABAAABAC`  와 pattern : `AABAC` 을 비교
  * BC (AABAC)
    * A = 3
    * B = 2
    * C = 4

  * Text를 와 Pattern을 비교할 때 BC를 이용

  * 첫번째로 모든 문자가 매칭
    * 다음 문자가 있는 경우, 다음 문자의 M-BC 만큼 이동
    * 매칭되고 다음 문자인 bc[txt[s + M]] = "A"이므로, M-3 = 2만큼 이동

  | A    | A    | B    | A    | C    | A    | A    | D    | A    | A    | B    | A    | A    | C    | B    | A    | C    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | A    | A    | B    | A    | C    |      |      |      |      |      |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

  * 6번째 index인 A와 C를 비교
    * 다른 문자가 존재하기 때문에, `max(1, j-bc[txt[s+j]])` 만큼 이동
    * 매칭이 안 된 마지막 문자인 `bc[txt[s+j]]` = A가 존재하므로 4-3만큼 이동 (+1)

  | A    | A    | B    | A    | C    | A    | A     | D    | A    | A    | B    | A    | A    | C    | B    | A    | C    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  |      |      | A    | A    | B    | A    | **C** |      |      |      |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |       |      |      |      |      |      |      |      |      |      |      |

  * 7번째 index인 D와 C를 비교
    * 다른 문자가 존재하기 때문에, `max(1, j-bc[txt[s+j]])` 만큼 이동
    * 매칭이 안 된 마지막 문자인 `bc[txt[s+j]]` = D가 존재하지 않으므로 4-(-1)만큼 이동 (+5)

  | A    | A    | B    | A    | C    | A    | A    | D     | A    | A    | B    | A    | A    | C    | B    | A    | C    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  |      |      |      | A    | A    | B    | A    | **C** |      |      |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |      |       |      |      |      |      |      |      |      |      |      |

  * 12번째 index인 A와 C를 비교
    * 다른 문자가 존재하기 때문에, `max(1, j-bc[txt[s+j]])` 만큼 이동
    * 매칭이 안 된 마지막 문자인   `bc[txt[s+j]]` = A가 존재하므로 4-3만큼 이동 (+1) 

  | A    | A    | B    | A    | C    | A    | A    | D    | A    | A    | B    | A    | A     | C    | B    | A    | C    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- |
  |      |      |      |      |      |      |      |      | A    | A    | B    | A    | **C** |      |      |      |      |
  |      |      |      |      |      |      |      |      |      |      |      |      |       |      |      |      |      |

  * 13번째 index부터 왼쪽으로 11번째 까지 비교
    * 2번 매칭이 되었기 때문에 j = (M-1)-2 = 2
    * 매칭이 안 된 마지막 문자인 A가 BC에 존재하므로 ` max(1, j - bc[txt[s + j]])`에 의해 max(1,-1) = 1 만큼 이동

  | A    | A    | B    | A    | C    | A    | A    | D    | A    | A    | B    | A     | A    | C    | B    | A    | C    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- | ---- |
  |      |      |      |      |      |      |      |      |      | A    | A    | **B** | A    | C    |      |      |      |
  |      |      |      |      |      |      |      |      |      |      |      |       |      |      |      |      |      |

  * 14번째 index 비교
    * 매칭이 안 된 마지막 문자 B가 bc에 존재하기 때문에 4-2 = 2만큼 이동

  | A    | A    | B    | A    | C    | A    | A    | D    | A    | A    | B    | A    | A    | C    | B     | A    | C    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- |
  |      |      |      |      |      |      |      |      |      |      | A    | A    | B    | A    | **C** |      |      |
  |      |      |      |      |      |      |      |      |      |      |      |      |      |      |       |      |      |

  * 오른쪽에서 3개의 문자열이 매칭되었기 때문에 j = 1
  * `max(1, j - bc[txt[s + j]])` = max(1,-3) = 1만큼 이동

  | A    | A    | B    | A    | C    | A    | A    | D    | A    | A    | B    | A    | A    | C    | B    | A    | C    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  |      |      |      |      |      |      |      |      |      |      |      |      | A    | A    | B    | A    | C    |
  |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

  * 최적의 경우, text에서 matching을 하는 문자가 pattern에 항상 없는 경우이고 이 때 시간 복잡도는 O(N/M)이다
    * 항상 M만큼 skip
  * 그러나 최악의 경우 "AAAAAA"에서 "AA" 같은 동일한 문자를 비교하는 경우, 항상 모든 문자열을 비교해야 되기 때문에 시간 복잡도는 O(NM)

* **Good Suffix**

  * asdasd
  * asdasd

  ```c++
  
  ```

* Bad Character와 Good Suffix 중 문자열을 가장 많이 skip 할 수 있는 방법으로 적용함





**Code**

```c++

```



